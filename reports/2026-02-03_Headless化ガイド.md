# Clawdboté‹ç”¨ã®HeadlessåŒ–ï¼ˆGUIä¸è¦åŒ–ï¼‰ã‚¬ã‚¤ãƒ‰

**ä½œæˆæ—¥:** 2026-02-03  
**å¯¾è±¡:** Clawdbotè‰¦éšŠé‹ç”¨  
**ç›®çš„:** GUIä¸è¦ã§è‡ªå‹•å®Ÿè¡Œå¯èƒ½ãªä½œæ¥­ã®å®Ÿè£…æ–¹æ³•

---

## 1. Claude Code/Clawdbotã®headlessãƒ¢ãƒ¼ãƒ‰æ´»ç”¨

### 1.1 Claude CLI headlessãƒ¢ãƒ¼ãƒ‰

```bash
# ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°JSONå‡ºåŠ›ã§ã®headlesså®Ÿè¡Œ
claude -p "ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆå†…å®¹" --output-format stream-json

# éå¯¾è©±ãƒ¢ãƒ¼ãƒ‰ã§ã®å®Ÿè¡Œ
claude --non-interactive -p "èª¿æŸ»ã‚¿ã‚¹ã‚¯" > result.json

# ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã§ã® batchå®Ÿè¡Œ
echo "è©³ç´°ãªãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ" | claude --stdin --output-format json
```

### 1.2 CI/CDçµ±åˆä¾‹

#### GitHub Actionsãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼
```yaml
# .github/workflows/daily-research.yml
name: Daily Research Task
on:
  schedule:
    - cron: '0 9 * * *'  # æ¯æ—¥9:00ã«å®Ÿè¡Œ
  workflow_dispatch:

jobs:
  research:
    runs-on: ubuntu-latest
    steps:
      - name: Setup Claude CLI
        run: |
          npm install -g claude-cli
          echo "${{ secrets.ANTHROPIC_API_KEY }}" > ~/.anthropic
      
      - name: Execute Research
        run: |
          claude -p "ä»Šæ—¥ã®æŠ€è¡“ãƒ‹ãƒ¥ãƒ¼ã‚¹ã‚’èª¿æŸ»ã—ã¦è¦ç´„" \
                 --output-format json > daily-research.json
      
      - name: Save Results
        uses: actions/upload-artifact@v3
        with:
          name: research-results
          path: daily-research.json
```

### 1.3 Clawdbot Gateway headlessé‹ç”¨

ç¾åœ¨ã®è¨­å®š: `/Users/user/Library/LaunchAgents/com.clawdbot.gateway.plist`
```xml
<!-- Headlessè‡ªå‹•èµ·å‹•è¨­å®š -->
<key>RunAtLoad</key><true/>
<key>KeepAlive</key><true/>

<!-- ãƒ­ã‚°å‡ºåŠ›è¨­å®š -->
<key>StandardOutPath</key>
<string>/Users/user/.clawdbot/logs/gateway.log</string>
<key>StandardErrorPath</key>
<string>/Users/user/.clawdbot/logs/gateway.err.log</string>
```

#### headlessç›£è¦–ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
```bash
#!/bin/bash
# scripts/clawdbot-health-check.sh

GATEWAY_PORT=18789
LOG_FILE="/Users/user/.clawdbot/logs/health.log"

check_gateway() {
    if curl -s "http://localhost:$GATEWAY_PORT/status" > /dev/null; then
        echo "$(date): Gateway OK" >> "$LOG_FILE"
        return 0
    else
        echo "$(date): Gateway DOWN - Restarting..." >> "$LOG_FILE"
        launchctl unload ~/Library/LaunchAgents/com.clawdbot.gateway.plist
        launchctl load ~/Library/LaunchAgents/com.clawdbot.gateway.plist
        return 1
    fi
}

check_gateway
```

---

## 2. ãƒ–ãƒ©ã‚¦ã‚¶è‡ªå‹•åŒ–ã®headlessåŒ–

### 2.1 Playwright headlessè¨­å®š

#### ç¾åœ¨ã®å®Ÿè£…ï¼ˆnote_auto_post_playwright.jsï¼‰ã®æ”¹è‰¯
```javascript
// Headlessæœ¬ç•ªç’°å¢ƒè¨­å®š
const browser = await chromium.launch({
  headless: process.env.NODE_ENV === 'production',  // ç’°å¢ƒã«å¿œã˜ã¦åˆ‡ã‚Šæ›¿ãˆ
  args: [
    '--no-sandbox',
    '--disable-dev-shm-usage',
    '--disable-blink-features=AutomationControlled',
    '--disable-features=VizDisplayCompositor'  // ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡å‰Šæ¸›
  ]
});

// Dockerç’°å¢ƒã§ã®è¨­å®š
const browser = await chromium.launch({
  headless: true,
  args: [
    '--no-sandbox',
    '--disable-setuid-sandbox',
    '--disable-dev-shm-usage',
    '--disable-background-timer-throttling',
    '--disable-backgrounding-occluded-windows',
    '--disable-renderer-backgrounding'
  ]
});
```

#### å®Œå…¨headless noteæŠ•ç¨¿ã‚¹ã‚¯ãƒªãƒ—ãƒˆ
```javascript
#!/usr/bin/env node
// scripts/note-headless-post.js

const { chromium } = require('playwright');

class HeadlessNotePoster {
  constructor() {
    this.cookiePath = process.env.COOKIE_PATH || './cookies.json';
    this.headless = process.env.HEADLESS !== 'false';
  }

  async launch() {
    return await chromium.launch({
      headless: this.headless,
      args: ['--no-sandbox', '--disable-dev-shm-usage']
    });
  }

  async post(article) {
    const browser = await this.launch();
    try {
      const context = await browser.newContext({
        viewport: { width: 1280, height: 720 },
        userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
      });
      
      // Cookieå¾©å…ƒ
      if (fs.existsSync(this.cookiePath)) {
        const cookies = JSON.parse(fs.readFileSync(this.cookiePath));
        await context.addCookies(cookies);
      }
      
      const page = await context.newPage();
      await this.performPost(page, article);
      
      // Cookieä¿å­˜
      const cookies = await context.cookies();
      fs.writeFileSync(this.cookiePath, JSON.stringify(cookies, null, 2));
      
      return true;
    } finally {
      await browser.close();
    }
  }
}

module.exports = HeadlessNotePoster;
```

### 2.2 Puppeteer headlesså®Ÿè£…

```javascript
// scripts/puppeteer-scraper.js
const puppeteer = require('puppeteer');

async function scrapeHeadless(url) {
  const browser = await puppeteer.launch({
    headless: 'new',  // æ–°ã—ã„headlessãƒ¢ãƒ¼ãƒ‰
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-gpu',
      '--window-size=1280,720'
    ]
  });

  const page = await browser.newPage();
  
  // ãƒ˜ãƒƒãƒ‰ãƒ¬ã‚¹æ¤œçŸ¥å›é¿
  await page.evaluateOnNewDocument(() => {
    Object.defineProperty(navigator, 'webdriver', {
      get: () => undefined,
    });
  });

  try {
    await page.goto(url, { waitUntil: 'networkidle2' });
    const result = await page.evaluate(() => {
      return document.body.innerText;
    });
    return result;
  } finally {
    await browser.close();
  }
}
```

---

## 3. å®šæœŸã‚¿ã‚¹ã‚¯ã®headlessåŒ–

### 3.1 macOS launchdè¨­å®š

#### æ¯æ—¥å®Ÿè¡Œã‚¿ã‚¹ã‚¯ã®è¨­å®š
```xml
<!-- ~/Library/LaunchAgents/com.clawdbot.daily-tasks.plist -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>com.clawdbot.daily-tasks</string>
  
  <key>ProgramArguments</key>
  <array>
    <string>/usr/bin/env</string>
    <string>node</string>
    <string>/Users/user/clawd/scripts/daily-automation.js</string>
  </array>
  
  <key>StartCalendarInterval</key>
  <dict>
    <key>Hour</key><integer>9</integer>
    <key>Minute</key><integer>0</integer>
  </dict>
  
  <key>StandardOutPath</key>
  <string>/Users/user/clawd/logs/daily-tasks.log</string>
  <key>StandardErrorPath</key>
  <string>/Users/user/clawd/logs/daily-tasks.err.log</string>
  
  <key>EnvironmentVariables</key>
  <dict>
    <key>PATH</key><string>/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin</string>
    <key>NODE_ENV</key><string>production</string>
  </dict>
</dict>
</plist>
```

#### launchdç®¡ç†ã‚³ãƒãƒ³ãƒ‰
```bash
# ã‚µãƒ¼ãƒ“ã‚¹ç™»éŒ²
launchctl load ~/Library/LaunchAgents/com.clawdbot.daily-tasks.plist

# ã‚µãƒ¼ãƒ“ã‚¹é–‹å§‹
launchctl start com.clawdbot.daily-tasks

# ã‚µãƒ¼ãƒ“ã‚¹åœæ­¢
launchctl stop com.clawdbot.daily-tasks

# ã‚µãƒ¼ãƒ“ã‚¹å‰Šé™¤
launchctl unload ~/Library/LaunchAgents/com.clawdbot.daily-tasks.plist
```

### 3.2 cronè¨­å®šï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ‰‹æ³•ï¼‰

```bash
# crontabè¨­å®šä¾‹
# æ¯æ—¥9:00ã«è¨˜äº‹æŠ•ç¨¿ãƒã‚§ãƒƒã‚¯
0 9 * * * cd /Users/user/clawd && node scripts/auto-post-check.js >> logs/cron.log 2>&1

# 2æ™‚é–“ã”ã¨ã«ä¾¡æ ¼ç›£è¦–
0 */2 * * * cd /Users/user/clawd && python3 price_monitor_v5.py --headless >> logs/price-monitor.log 2>&1

# æ¯é€±æœˆæ›œæ—¥9:00ã«ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
0 9 * * 1 cd /Users/user/clawd && node scripts/weekly-report.js >> logs/weekly.log 2>&1
```

### 3.3 å®Ÿè£…ã‚¹ã‚¯ãƒªãƒ—ãƒˆä¾‹

#### æ—¥æ¬¡è‡ªå‹•åŒ–ã‚¿ã‚¹ã‚¯
```javascript
// scripts/daily-automation.js
const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');

class DailyAutomation {
  constructor() {
    this.logPath = '/Users/user/clawd/logs/daily-automation.log';
    this.tasksConfig = './config/daily-tasks.json';
  }

  log(message) {
    const timestamp = new Date().toISOString();
    const logEntry = `${timestamp}: ${message}\n`;
    fs.appendFileSync(this.logPath, logEntry);
    console.log(message);
  }

  async runTask(taskName, command) {
    return new Promise((resolve, reject) => {
      this.log(`[${taskName}] é–‹å§‹: ${command}`);
      
      exec(command, { cwd: '/Users/user/clawd' }, (error, stdout, stderr) => {
        if (error) {
          this.log(`[${taskName}] ã‚¨ãƒ©ãƒ¼: ${error.message}`);
          reject(error);
        } else {
          this.log(`[${taskName}] å®Œäº†: ${stdout.trim()}`);
          resolve(stdout);
        }
      });
    });
  }

  async execute() {
    const tasks = [
      {
        name: 'price-check',
        command: 'python3 price_monitor_v5.py --headless --quiet'
      },
      {
        name: 'article-queue',
        command: 'node note_auto_post_playwright.js --check-only'
      },
      {
        name: 'memory-update',
        command: 'node scripts/update-memory.js'
      }
    ];

    this.log('=== æ—¥æ¬¡è‡ªå‹•åŒ–ã‚¿ã‚¹ã‚¯é–‹å§‹ ===');
    
    for (const task of tasks) {
      try {
        await this.runTask(task.name, task.command);
      } catch (error) {
        this.log(`[${task.name}] ã‚¿ã‚¹ã‚¯å¤±æ•—: ${error.message}`);
      }
    }
    
    this.log('=== æ—¥æ¬¡è‡ªå‹•åŒ–ã‚¿ã‚¹ã‚¯å®Œäº† ===');
  }
}

if (require.main === module) {
  const automation = new DailyAutomation();
  automation.execute().catch(console.error);
}
```

---

## 4. é€šçŸ¥ã®headlessåŒ–

### 4.1 Telegram Bot APIçµ±åˆ

#### Botè¨­å®šã¨Tokenå–å¾—
```bash
# 1. @BotFatherã§Botä½œæˆ
# 2. ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ç’°å¢ƒå¤‰æ•°ã«è¨­å®š
export TELEGRAM_BOT_TOKEN="your_bot_token"
export TELEGRAM_CHAT_ID="your_chat_id"
```

#### Telegramé€šçŸ¥ã‚¯ãƒ©ã‚¹
```javascript
// lib/telegram-notifier.js
const https = require('https');

class TelegramNotifier {
  constructor(token, chatId) {
    this.token = token;
    this.chatId = chatId;
    this.apiUrl = `https://api.telegram.org/bot${token}`;
  }

  async sendMessage(text, options = {}) {
    const payload = {
      chat_id: this.chatId,
      text: text,
      parse_mode: options.parseMode || 'Markdown',
      disable_web_page_preview: options.disablePreview || true
    };

    return new Promise((resolve, reject) => {
      const data = JSON.stringify(payload);
      const requestOptions = {
        hostname: 'api.telegram.org',
        path: `/bot${this.token}/sendMessage`,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(data)
        }
      };

      const req = https.request(requestOptions, (res) => {
        let body = '';
        res.on('data', chunk => body += chunk);
        res.on('end', () => {
          if (res.statusCode === 200) {
            resolve(JSON.parse(body));
          } else {
            reject(new Error(`HTTP ${res.statusCode}: ${body}`));
          }
        });
      });

      req.on('error', reject);
      req.write(data);
      req.end();
    });
  }

  async sendDocument(filePath, caption = '') {
    // ãƒ•ã‚¡ã‚¤ãƒ«é€ä¿¡ã®å®Ÿè£…
    const FormData = require('form-data');
    const form = new FormData();
    form.append('chat_id', this.chatId);
    form.append('document', fs.createReadStream(filePath));
    if (caption) form.append('caption', caption);
    
    // å®Ÿè£…è©³ç´°...
  }

  // ç·Šæ€¥é€šçŸ¥ï¼ˆéŸ³ä»˜ãï¼‰
  async sendAlert(text) {
    return this.sendMessage(`ğŸš¨ *ALERT*\n\n${text}`, {
      parseMode: 'Markdown',
      disableNotification: false  // é€šçŸ¥éŸ³ON
    });
  }

  // å®šæœŸãƒ¬ãƒãƒ¼ãƒˆï¼ˆéŸ³ç„¡ã—ï¼‰
  async sendReport(text) {
    return this.sendMessage(`ğŸ“Š *Report*\n\n${text}`, {
      parseMode: 'Markdown',
      disableNotification: true  // é€šçŸ¥éŸ³OFF
    });
  }
}

module.exports = TelegramNotifier;
```

### 4.2 Webhooké€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 

#### Generic Webhook Notifier
```javascript
// lib/webhook-notifier.js
const https = require('https');
const crypto = require('crypto');

class WebhookNotifier {
  constructor(config) {
    this.webhooks = config.webhooks || [];
    this.secret = config.secret;
  }

  generateSignature(payload, secret) {
    return crypto
      .createHmac('sha256', secret)
      .update(payload)
      .digest('hex');
  }

  async notify(event, data) {
    const payload = JSON.stringify({
      timestamp: new Date().toISOString(),
      event: event,
      data: data,
      source: 'clawdbot-headless'
    });

    const promises = this.webhooks.map(webhook => 
      this.sendWebhook(webhook, payload)
    );

    return Promise.allSettled(promises);
  }

  async sendWebhook(webhookUrl, payload) {
    const url = new URL(webhookUrl);
    const headers = {
      'Content-Type': 'application/json',
      'User-Agent': 'Clawdbot-Webhook/1.0'
    };

    if (this.secret) {
      headers['X-Hub-Signature-256'] = 'sha256=' + this.generateSignature(payload, this.secret);
    }

    return new Promise((resolve, reject) => {
      const req = https.request({
        hostname: url.hostname,
        port: url.port,
        path: url.pathname + url.search,
        method: 'POST',
        headers: headers
      }, (res) => {
        resolve({ status: res.statusCode, webhook: webhookUrl });
      });

      req.on('error', reject);
      req.write(payload);
      req.end();
    });
  }
}

module.exports = WebhookNotifier;
```

---

## 5. èªè¨¼ã®headlessåŒ–

### 5.1 OAuth Device Flowå®Ÿè£…

```javascript
// lib/oauth-device-flow.js
const https = require('https');
const fs = require('fs');

class OAuthDeviceFlow {
  constructor(clientId, clientSecret, authUrl, tokenUrl) {
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.authUrl = authUrl;
    this.tokenUrl = tokenUrl;
    this.tokenPath = './tokens.json';
  }

  // Step 1: ãƒ‡ãƒã‚¤ã‚¹èªè¨¼ã‚³ãƒ¼ãƒ‰å–å¾—
  async requestDeviceCode() {
    const params = new URLSearchParams({
      client_id: this.clientId,
      scope: 'read write'
    });

    const response = await this.makeRequest(this.authUrl + '/device', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: params.toString()
    });

    return response;
  }

  // Step 2: ãƒãƒ¼ãƒªãƒ³ã‚°ã§ãƒˆãƒ¼ã‚¯ãƒ³å–å¾—
  async pollForToken(deviceCode, interval = 5) {
    console.log('ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼å®Œäº†ã¾ã§å¾…æ©Ÿä¸­...');
    
    while (true) {
      await new Promise(resolve => setTimeout(resolve, interval * 1000));
      
      try {
        const token = await this.requestToken(deviceCode);
        this.saveTokens(token);
        console.log('èªè¨¼å®Œäº†ï¼ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜ã—ã¾ã—ãŸã€‚');
        return token;
      } catch (error) {
        if (error.message.includes('authorization_pending')) {
          continue; // ã¾ã èªè¨¼ã•ã‚Œã¦ã„ãªã„
        } else {
          throw error;
        }
      }
    }
  }

  async requestToken(deviceCode) {
    const params = new URLSearchParams({
      grant_type: 'urn:ietf:params:oauth:grant-type:device_code',
      device_code: deviceCode,
      client_id: this.clientId,
      client_secret: this.clientSecret
    });

    return this.makeRequest(this.tokenUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: params.toString()
    });
  }

  // ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
  async refreshToken() {
    const tokens = this.loadTokens();
    if (!tokens.refresh_token) {
      throw new Error('ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ãƒˆãƒ¼ã‚¯ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“');
    }

    const params = new URLSearchParams({
      grant_type: 'refresh_token',
      refresh_token: tokens.refresh_token,
      client_id: this.clientId,
      client_secret: this.clientSecret
    });

    const newTokens = await this.makeRequest(this.tokenUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: params.toString()
    });

    this.saveTokens(newTokens);
    return newTokens;
  }

  saveTokens(tokens) {
    fs.writeFileSync(this.tokenPath, JSON.stringify(tokens, null, 2));
  }

  loadTokens() {
    if (fs.existsSync(this.tokenPath)) {
      return JSON.parse(fs.readFileSync(this.tokenPath));
    }
    return null;
  }

  async makeRequest(url, options) {
    // HTTPS requestå®Ÿè£…...
  }
}
```

### 5.2 APIãƒˆãƒ¼ã‚¯ãƒ³ç®¡ç†

```javascript
// lib/token-manager.js
const fs = require('fs');
const crypto = require('crypto');

class TokenManager {
  constructor(configPath = './config/tokens.encrypted') {
    this.configPath = configPath;
    this.encryptionKey = process.env.TOKEN_ENCRYPTION_KEY || this.generateKey();
  }

  generateKey() {
    return crypto.randomBytes(32).toString('hex');
  }

  encrypt(text) {
    const cipher = crypto.createCipher('aes-256-cbc', this.encryptionKey);
    let encrypted = cipher.update(text, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
  }

  decrypt(encryptedText) {
    const decipher = crypto.createDecipher('aes-256-cbc', this.encryptionKey);
    let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  }

  saveToken(serviceName, token) {
    let tokens = {};
    if (fs.existsSync(this.configPath)) {
      tokens = JSON.parse(this.decrypt(fs.readFileSync(this.configPath, 'utf8')));
    }
    
    tokens[serviceName] = {
      token: token,
      createdAt: new Date().toISOString(),
      expiresAt: token.expires_at || null
    };

    const encrypted = this.encrypt(JSON.stringify(tokens, null, 2));
    fs.writeFileSync(this.configPath, encrypted);
  }

  getToken(serviceName) {
    if (!fs.existsSync(this.configPath)) {
      return null;
    }

    const tokens = JSON.parse(this.decrypt(fs.readFileSync(this.configPath, 'utf8')));
    return tokens[serviceName] || null;
  }

  isTokenValid(serviceName) {
    const tokenData = this.getToken(serviceName);
    if (!tokenData) return false;
    
    if (tokenData.expiresAt) {
      return new Date() < new Date(tokenData.expiresAt);
    }
    
    return true; // æœŸé™ãªã—ãƒˆãƒ¼ã‚¯ãƒ³
  }
}

module.exports = TokenManager;
```

---

## 6. ç¾åœ¨ã®è‰¦éšŠé‹ç”¨ã§headlessåŒ–ã§ãã‚‹ä½œæ¥­

### 6.1 å³åº§ã«headlessåŒ–å¯èƒ½ãªä½œæ¥­

#### A. ä¾¡æ ¼ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 
**ç¾åœ¨:** `price_monitor_v5.py`  
**headlessåŒ–æ–¹æ³•:**
```bash
# cronè¨­å®š
0 */2 * * * cd /Users/user/clawd && python3 price_monitor_v5.py --headless --notify-telegram
```

#### B. note.comè‡ªå‹•æŠ•ç¨¿
**ç¾åœ¨:** `note_auto_post_playwright.js`  
**å¿…è¦ãªå¤‰æ›´:**
```javascript
// headless: false â†’ headless: true
const browser = await chromium.launch({
  headless: process.env.NODE_ENV === 'production',
  args: ['--no-sandbox', '--disable-dev-shm-usage']
});
```

#### C. ã‚¸ãƒ¢ãƒ†ã‚£ãƒ¼ç›£è¦–
**ç¾åœ¨:** `jmty_filter.py`  
**å®Ÿè£…ã‚¹ã‚¯ãƒªãƒ—ãƒˆ:**
```bash
#!/bin/bash
# scripts/jmty-headless.sh
cd /Users/user/clawd
python3 jmty_filter.py --headless 2>&1 | tee logs/jmty-$(date +%Y%m%d).log

# Telegramé€šçŸ¥
if [ $? -eq 0 ]; then
  node scripts/telegram-notify.js "ã‚¸ãƒ¢ãƒ†ã‚£ãƒ¼ç›£è¦–å®Œäº†: $(date)"
else
  node scripts/telegram-notify.js "âš ï¸ ã‚¸ãƒ¢ãƒ†ã‚£ãƒ¼ç›£è¦–ã‚¨ãƒ©ãƒ¼: $(date)"
fi
```

### 6.2 ä¸­æœŸçš„ã«headlessåŒ–ã™ã‚‹ä½œæ¥­

#### A. ãƒ¡ãƒ¢ãƒªæ›´æ–°ã‚¿ã‚¹ã‚¯
**å®Ÿè£…ä¾‹:**
```javascript
// scripts/memory-automation.js
const fs = require('fs');
const path = require('path');

class MemoryAutomation {
  constructor() {
    this.memoryDir = '/Users/user/clawd/memory';
    this.mainMemoryFile = '/Users/user/clawd/MEMORY.md';
  }

  async consolidateDailyMemories() {
    const today = new Date();
    const threeDaysAgo = new Date(today);
    threeDaysAgo.setDate(today.getDate() - 3);

    const dailyFiles = fs.readdirSync(this.memoryDir)
      .filter(file => file.match(/^\d{4}-\d{2}-\d{2}\.md$/))
      .filter(file => {
        const fileDate = new Date(file.split('.')[0]);
        return fileDate < threeDaysAgo;
      });

    // é‡è¦ãªæƒ…å ±ã‚’æŠ½å‡ºã—ã¦MEMORY.mdã«çµ±åˆ
    for (const file of dailyFiles) {
      await this.processDaily(path.join(this.memoryDir, file));
    }
  }

  async processDaily(filePath) {
    const content = fs.readFileSync(filePath, 'utf-8');
    const importantSections = this.extractImportant(content);
    
    if (importantSections.length > 0) {
      this.appendToMainMemory(importantSections, path.basename(filePath));
    }
  }
}
```

#### B. ãƒ¬ãƒãƒ¼ãƒˆè‡ªå‹•ç”Ÿæˆ
```javascript
// scripts/daily-report.js
const TelegramNotifier = require('../lib/telegram-notifier');

async function generateDailyReport() {
  const report = {
    date: new Date().toISOString().split('T')[0],
    tasks: await getCompletedTasks(),
    metrics: await getMetrics(),
    alerts: await getAlerts()
  };

  const message = formatReport(report);
  
  const telegram = new TelegramNotifier(
    process.env.TELEGRAM_BOT_TOKEN,
    process.env.TELEGRAM_CHAT_ID
  );
  
  await telegram.sendReport(message);
}
```

### 6.3 headlessåŒ–å®Ÿè£…ã®å„ªå…ˆé †ä½

#### æœ€å„ªå…ˆï¼ˆå³åº§ã«å®Ÿè£…ï¼‰
1. **ä¾¡æ ¼ç›£è¦–ã®cronåŒ–** - 2æ™‚é–“ã”ã¨ã®è‡ªå‹•å®Ÿè¡Œ
2. **noteæŠ•ç¨¿ã®headlessåŒ–** - GUIä¸è¦ã§ã®è¨˜äº‹æŠ•ç¨¿
3. **Clawdbot Gatewayç›£è¦–** - è‡ªå‹•å†èµ·å‹•æ©Ÿèƒ½

#### é«˜å„ªå…ˆï¼ˆ1é€±é–“ä»¥å†…ï¼‰
1. **Telegramé€šçŸ¥çµ±åˆ** - å…¨ã‚¿ã‚¹ã‚¯ã®çµæœé€šçŸ¥
2. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–** - å¤±æ•—æ™‚ã®è‡ªå‹•å¾©æ—§
3. **ãƒ­ã‚°ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ** - çµ±ä¸€ã•ã‚ŒãŸãƒ­ã‚°å‡ºåŠ›

#### ä¸­å„ªå…ˆï¼ˆ1ãƒ¶æœˆä»¥å†…ï¼‰
1. **OAuthèªè¨¼ã®è‡ªå‹•åŒ–** - APIæ¥ç¶šã®è‡ªå‹•èªè¨¼
2. **ãƒªã‚½ãƒ¼ã‚¹ç›£è¦–** - CPU/ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®ç›£è¦–
3. **ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—è‡ªå‹•åŒ–** - é‡è¦ãƒ‡ãƒ¼ã‚¿ã®å®šæœŸãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—

---

## 7. å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### 7.1 ç’°å¢ƒè¨­å®š
- [ ] Node.jsç’°å¢ƒï¼ˆv25.4.0ï¼‰ç¢ºèªæ¸ˆã¿
- [ ] Playwrightä¾å­˜é–¢ä¿‚ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿
- [ ] Python3ç’°å¢ƒç¢ºèªæ¸ˆã¿
- [ ] launchdè¨­å®šæ¨©é™ç¢ºèªæ¸ˆã¿

### 7.2 ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
- [ ] APIãƒˆãƒ¼ã‚¯ãƒ³ã®æš—å·åŒ–ä¿å­˜
- [ ] Cookieæƒ…å ±ã®å®‰å…¨ãªç®¡ç†
- [ ] ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«ã®æ¨©é™è¨­å®š
- [ ] èªè¨¼æƒ…å ±ã®ç’°å¢ƒå¤‰æ•°åŒ–

### 7.3 ç›£è¦–ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆ
- [ ] Telegram Botè¨­å®šå®Œäº†
- [ ] ã‚¨ãƒ©ãƒ¼é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ æ§‹ç¯‰
- [ ] ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯æ©Ÿèƒ½å®Ÿè£…
- [ ] ãƒ­ã‚°ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š

### 7.4 ãƒ†ã‚¹ãƒˆãƒ»ãƒ‡ãƒ—ãƒ­ã‚¤
- [ ] headlessãƒ¢ãƒ¼ãƒ‰ã§ã®å‹•ä½œç¢ºèª
- [ ] cron/launchdã§ã®å®Ÿè¡Œãƒ†ã‚¹ãƒˆ
- [ ] å¤±æ•—ã‚±ãƒ¼ã‚¹ã®ãƒ†ã‚¹ãƒˆ
- [ ] ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ‰‹é †ã®ç¢ºç«‹

---

## 8. ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### 8.1 ã‚ˆãã‚ã‚‹å•é¡Œ

#### Playwright headlessã§èªè¨¼å¤±æ•—
```javascript
// è§£æ±ºç­–ï¼šUser-Agentã¨viewportã®è¨­å®š
await context.newContext({
  viewport: { width: 1280, height: 720 },
  userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
});
```

#### launchdèµ·å‹•å¤±æ•—
```bash
# ãƒ‡ãƒãƒƒã‚°æ–¹æ³•
launchctl list | grep clawdbot
tail -f /Users/user/.clawdbot/logs/gateway.err.log

# æ¨©é™ç¢ºèª
ls -la ~/Library/LaunchAgents/com.clawdbot.*.plist
```

#### ãƒ¡ãƒ¢ãƒªä¸è¶³
```bash
# Node.jsãƒ¡ãƒ¢ãƒªåˆ¶é™è¨­å®š
export NODE_OPTIONS="--max-old-space-size=2048"
```

### 8.2 ç·Šæ€¥æ™‚å¯¾å¿œ

```bash
# å…¨ã‚µãƒ¼ãƒ“ã‚¹åœæ­¢
launchctl stop com.clawdbot.gateway
launchctl stop com.clawdbot.daily-tasks

# æ‰‹å‹•å®Ÿè¡Œã§ãƒ†ã‚¹ãƒˆ
cd /Users/user/clawd
NODE_ENV=development node scripts/test-headless.js

# ãƒ­ã‚°ç¢ºèª
tail -f logs/*.log
```

---

## 9. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

### 9.1 ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡å‰Šæ¸›
- Playwright: `--disable-dev-shm-usage`
- ãƒ¡ãƒ¢ãƒªåˆ¶é™: `--max-old-space-size`
- åŒæ™‚å®Ÿè¡Œåˆ¶é™: queueç®¡ç†

### 9.2 å®Ÿè¡Œæ™‚é–“çŸ­ç¸®
- Cookieå†åˆ©ç”¨ã«ã‚ˆã‚‹ãƒ­ã‚°ã‚¤ãƒ³ã‚¹ã‚­ãƒƒãƒ—
- å¿…è¦æœ€å°é™ã®ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿
- ä¸¦åˆ—å‡¦ç†ã®æ´»ç”¨

---

**ä½œæˆè€…:** AI Assistant  
**ãƒãƒ¼ã‚¸ãƒ§ãƒ³:** 1.0  
**æœ€çµ‚æ›´æ–°:** 2026-02-03 04:30